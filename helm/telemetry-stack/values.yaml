# Default values for telemetry-stack
# This is a YAML-formatted file.

# Global settings
global:
  imagePullPolicy: Never
  prometheusOperator:
    enabled: false

# Security configuration
security:
  # Single shared secret for REST API authentication
  # Users include this as X-API-Key header or Authorization: Bearer token
  apiKey: "telemetry-api-secret-2025"
  # Internal service-to-service authentication token
  serviceToken: "internal-service-token-2025"

# Kubernetes Secrets configuration
secrets:
  # Enable creation of Kubernetes secrets
  enabled: true
  # Use existing secret instead of creating new one (optional)
  # existingSecret: "my-existing-secret"
  # API key for REST API authentication
  apiKey: "telemetry-api-secret-2025"
  # Service token for internal service communication
  serviceToken: "internal-service-token-2025"

# InfluxDB configuration
influxdb:
  enabled: true
  image:
    repository: influxdb
    tag: "2.7"
  service:
    type: ClusterIP
    port: 8086
  persistence:
    enabled: true
    size: 1Gi
  env:
    initMode: setup
    adminUser: admin
    adminPassword: admin123
    org: telemetryorg
    bucket: telem_bucket
    adminToken: supersecrettoken

# API Service configuration
api:
  enabled: true
  name: api
  image:
    repository: api
    tag: latest
  service:
    type: ClusterIP
    port: 8080
  nodePort:
    enabled: true
    port: 30081
  env:
    influxdbUrl: "http://influxdb:8086"
    influxdbToken: "supersecrettoken"
    influxdbOrg: "telemetryorg"
    influxdbBucket: "telem_bucket"

# Collector configuration
collector:
  enabled: true
  name: collector
  image:
    repository: collector
    tag: latest
  service:
    type: ClusterIP
    port: 8080
  env:
    influxdbUrl: "http://influxdb:8086"
    influxdbToken: "supersecrettoken"
    influxdbOrg: "telemetryorg"
    influxdbBucket: "telem_bucket"
    msgQueueAddr: "http://msg-queue-proxy-service:8080"
    msgQueueTopic: "telemetry"
    msgQueueGroup: "telemetry_group"
    msgQueueConsumerName: "collector"
    maxPartitions: "2"  # Must match telemetry topic partition count
  # Health check configuration
  healthCheck:
    path: "/health"
    initialDelaySeconds: 60     # Wait 60sbectl before first liveness check (depends on msg-queue + influxdb)
    periodSeconds: 15          # Check every 15s
    timeoutSeconds: 10         # Allow 10s for response
    failureThreshold: 5        # Allow 5 failures before restart
    readinessInitialDelaySeconds: 25  # Wait 25s before first readiness check
    readinessPeriodSeconds: 10        # Check readiness every 10s
    readinessTimeoutSeconds: 5        # Allow 5s for readiness response
    readinessFailureThreshold: 3      # Mark unready after 3 failures

# Message Queue configuration
msgQueue:
  enabled: true
  name: msg-queue
  replicaCount: 2  # Scale to 2 replicas for load balancing
  useStatefulSet: true  # Use StatefulSet for proper broker indexing
  image:
    repository: msg-queue
    tag: latest
  service:
    type: ClusterIP  # Changed from ClusterIP to LoadBalancer
    port: 8080
    # Optional: specify external port
    # nodePort: 30080  # For NodePort type
  # Persistence configuration
  persistence:
    enabled: true  # Enable for StatefulSet with per-replica storage
    size: 1Gi
    # storageClass: ""  # Use default storage class
  env:
    port: "8080"
    brokerIndex: "0"      # Will be overridden by StatefulSet pod ordinal
    brokerCount: "2"      # Should match replicaCount for proper partitioning
    topics: "telemetry:2" # Fixed to match actual partition count
  # Health check configuration
  healthCheck:
    path: "/health"
    initialDelaySeconds: 60     # Wait 60s before first liveness check
    periodSeconds: 15          # Check every 15s
    timeoutSeconds: 10         # Allow 10s for response
    failureThreshold: 5        # Allow 5 failures before restart
    readinessInitialDelaySeconds: 30  # Wait 30s before first readiness check
    readinessPeriodSeconds: 10        # Check readiness every 10s
    readinessTimeoutSeconds: 5        # Allow 5s for readiness response
    readinessFailureThreshold: 3      # Mark unready after 3 failures
  # Ingress configuration for advanced load balancing
  ingress:
    enabled: false  # Set to true to enable ingress
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # nginx.ingress.kubernetes.io/rewrite-target: /
    hosts:
      - host: msg-queue.local
        paths:
          - path: /
            pathType: Prefix
    tls: []
    #  - secretName: msg-queue-tls
    #    hosts:
    #      - msg-queue.local

# Message Queue Proxy configuration
msgQueueProxy:
  enabled: true
  name: msg-queue-proxy
  replicaCount: 1
  image:
    repository: msg-queue-proxy
    tag: latest
  service:
    type: ClusterIP
    port: 8080
    # Optional: external load balancer
    external:
      enabled: false
      type: LoadBalancer
  env:
    port: "8080"
    brokerService: "msg-queue"
    brokerCount: "2"
    virtualNodes: "150"
    maxPartitions: "2"
    healthIntervalSeconds: "30"
    # Increase timeout settings to handle high-volume data processing
    requestTimeoutSeconds: "60"     # Timeout for forwarding requests to brokers
    connectionTimeoutSeconds: "10"  # Timeout for establishing connections
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "100m"
  # Health check configuration
  healthCheck:
    path: "/health"
    initialDelaySeconds: 45     # Wait 45s before first liveness check (depends on msg-queue)
    periodSeconds: 15          # Check every 15s
    timeoutSeconds: 10         # Allow 10s for response
    failureThreshold: 5        # Allow 5 failures before restart
    readinessInitialDelaySeconds: 15  # Wait 15s before first readiness check
    readinessPeriodSeconds: 10        # Check readiness every 10s
    readinessTimeoutSeconds: 5        # Allow 5s for readiness response
    readinessFailureThreshold: 3      # Mark unready after 3 failures
  # Monitoring configuration
  monitoring:
    enabled: true
    metricsPath: "/metrics"
    statsPath: "/stats"

# Streamer configuration
streamer:
  enabled: true
  name: streamer
  image:
    repository: streamer
    tag: latest
  service:
    type: ClusterIP
    port: 8080
  env:
    csvPath: "/data/dcgm_metrics_20250718_134233.csv"
    csvDelayMs: "20"
    useHttpQueue: "true"
    port: "8080"
    msgQueueAddr: "http://msg-queue-proxy-service:8080"
    msgQueueTopic: "telemetry"
    msgQueueGroup: "telemetry_group"
    msgQueueProducerName: "streamer"
    maxPartitions: "2"  # Must match telemetry topic partition count
  # Health check configuration
  healthCheck:
    path: "/health"
    initialDelaySeconds: 60     # Wait 45s before first liveness check (depends on msg-queue)
    periodSeconds: 15          # Check every 15s
    timeoutSeconds: 10         # Allow 10s for response
    failureThreshold: 5        # Allow 5 failures before restart
    readinessInitialDelaySeconds: 20  # Wait 20s before first readiness check
    readinessPeriodSeconds: 10        # Check readiness every 10s
    readinessTimeoutSeconds: 5        # Allow 5s for readiness response
    readinessFailureThreshold: 3      # Mark unready after 3 failures
  volume:
    enabled: false
    hostPath: "/run/desktop/mnt/host/c/Users/peaswaran/telemetry_Punitha"

# ServiceAccount configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# Prometheus configuration
prometheus:
  enabled: true
  image:
    repository: prom/prometheus
    tag: v2.45.0
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 9090
    # Set to NodePort for external access if needed
    # nodePort: 30090
  persistence:
    enabled: true
    size: 2Gi
    storageClass: "" # Use default storage class
  retention: 15d
  scrapeInterval: 15s
  evaluationInterval: 15s
  # Service account for Prometheus with cluster permissions
  serviceAccount:
    create: true
    name: "prometheus"
  alerting:
    enabled: false
    alertmanager:
      url: http://alertmanager:9093

# Grafana configuration
grafana:
  enabled: true
  image:
    repository: grafana/grafana
    tag: 10.1.0
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 3000
    # Set to NodePort for external access if needed
    # nodePort: 30300
  adminPassword: admin123
  persistence:
    enabled: true
    size: 1Gi
    storageClass: "" # Use default storage class
  # Resources for Grafana
  resources:
    limits:
      cpu: 500m
      memory: 1Gi
    requests:
      cpu: 100m
      memory: 512Mi
  datasources:
    enabled: true
    prometheus:
      url: http://prometheus-service:9090
    influxdb:
      url: http://influxdb:8086
      database: telem_bucket
      user: admin
      password: admin123